Forge Compiler Project
/*****************************Date:21 Oct 2024***********************************/
The Forge project is an ongoing development of a custom compiler for a new programming language called Forge, with a special focus on targeting the Linux ARM64 architecture. This compiler is designed to process code written in the Forge language, translating it into machine code optimized for ARM64 systems. The project is in its early stages, concentrating on core functionalities such as parsing input files, managing tokens, and setting up essential file-handling mechanisms. Future developments will include expanding the language's syntax and semantics, creating an efficient code generation pipeline, and optimizing the compiled output for performance across ARM64-based Linux platforms.

/***********Start-21/10/2024(Overview)***********/

CMakeLists.txt:

    This file is used to set up the CMake project for the Forge compiler. It specifies that the project will use C++ standard 23 and includes src/main.cpp as the source file for the executable named "Forge."

main.cpp:

    Tokenization:
        The code reads an input .Fg file, which contains a simple syntax for returning integer literals (e.g., ret 0;).
        The function Tokenize() breaks down the input string into tokens based on recognized patterns:
            ret keyword (return statement)
            Integer literals (numbers)
            Semicolons (;)
        It returns a list of tokens where each token is of type _Ret, _Intliteral, or _SemiColon.

    Converting Tokens to Assembly:
        The function TokensToAsm() takes the list of tokens and generates corresponding ARM64 assembly instructions.
        Specifically, it looks for a sequence of tokens representing ret <int>; and converts them into assembly:
            Moves the integer literal to register x0.
            Executes a system call (svc 0) to exit with the return code.

    Main Execution:
        The main() function reads a .Fg input file, tokenizes its contents, and converts the tokens into assembly.
        The generated assembly code is written to out.s.
        The program then assembles (as -o out.o out.s) and links (ld -o out out.o) the code to produce an executable named out.

main.Fg:

    This is a simple .Fg file that contains a single statement:

        ret 0;

    This tells the program to return 0 as the exit code, which will be translated into assembly and then compiled into an executable.

/***********End-21/10/2024(Overview)***********/


/***********Start-24/10/2024(Overview)***********/

Today, I made solid progress on my compiler project by writing the Tokenization.hpp, Parser.hpp, and generation.hpp files. I built the tokenizer to break source code into tokens, the parser to convert those tokens into an AST, and the generator to transform the AST into ARM64 assembly code. This lays the groundwork for turning high-level code into executable assembly.

1. Tokenization (Tokenization.hpp)

This file is responsible for breaking down the input source code into smaller components called tokens, which represent basic building blocks like keywords, literals, and symbols.

    Tokens: It defines different types of tokens (_Ret, _Intliteral, and _SemiColon).
        _Ret: Represents the "ret" keyword.
        _Intliteral: Represents integer values (e.g., 123).
        _SemiColon: Represents the semicolon (;).
    Tokenizer:
        peek(): Looks ahead at the next character to see what comes next without advancing the current position.
        consume(): Reads the current character and advances the position.
        Tokenize(): This is the main function. It loops through the source code, recognizing sequences that match token types (like "ret" or integer literals) and skipping over whitespace. It collects these tokens into a vector and returns them.

2. Parsing (Parser.hpp)

This file turns the tokens generated by the tokenizer into a higher-level structure called an Abstract Syntax Tree (AST), which represents the logical structure of the code.

    Node Structures:
        NodeExpr: Represents an integer literal expression (e.g., 123).
        NodeRet: Represents a return statement, which contains an integer expression.

    Parser:
        peek() and consume(): Similar to the tokenizer, but this works on tokens instead of characters.
        parse_expr(): Looks for integer literals and builds a NodeExpr for them.
        parse(): Handles return statements (ret), ensuring that a valid integer expression follows the ret keyword and that the statement ends with a semicolon (;). If something is wrong (e.g., missing semicolon or invalid expression), it outputs an error.

3. Code Generation (generation.hpp)

This file is responsible for taking the parsed AST and converting it into assembly code.

    Generator:
        Takes in the root NodeRet (return statement).
        generate(): Converts the AST into ARM64 assembly. Specifically, it:
            Moves the integer literal into the x0 register.
            Moves the system call number for exit (93) into the x8 register.
            Executes the system call (svc 0) to terminate the program.

Overall Workflow

    The tokenizer reads the source code (e.g., ret 0;) and breaks it into tokens.
    The parser uses these tokens to create an AST, representing a return statement with an integer.
    The generator takes the AST and outputs ARM64 assembly code, which returns the integer from the program.

/***********end-24/10/2024(Overview)***********/
